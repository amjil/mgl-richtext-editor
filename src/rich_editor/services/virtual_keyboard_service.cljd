(ns rich-editor.services.virtual-keyboard-service
  (:require
   ["package:flutter/services.dart" :as service]
   ["package:flutter/widgets.dart" :as w]
   [virtual-keyboard.input-control :as control]
   [virtual-keyboard.keyboard-candidates :as kc]
   [virtual-keyboard.zip-utils :as zip-utils]
   [virtual-keyboard.fst-reader :as fst-reader]
   [rich-editor.model.node :as node]
   [rich-editor.command.text-commands :as cmd]
   [rich-editor.state :as state]
   [rich-editor.model.selection :as sel]
   [rich-editor.utils.delta :as delta-utils]
   [rich-editor.utils.text-diff :as text-diff]))

;; =============================================================
;; Virtual keyboard initialization service
;; References mgl-notes-app implementation
;; =============================================================

(defonce initialized? (atom false))
(defonce last-synced-state (atom nil))

(defn sync-to-editor!
  "Sync virtual keyboard state to editor
   When virtual keyboard text or selection changes, update the editor's document and selection"
  []
  (let [editor-state @state/!editor-state
        selection (:selection editor-state)]
    (when selection
      (let [normalized (sel/normalize selection)
            path (:path (:start normalized))
            ks (node/path->ks path)
            delta-ks (if (some #{:delta} path) ks (conj ks :data :delta))
            delta (get-in editor-state (cons :doc delta-ks))
            editor-text (delta-utils/delta->text delta)
            editor-start (:offset (:start normalized))
            editor-end (:offset (:end normalized))
            
            kb-val @control/editing-value
            kb-text (.-text kb-val)
            kb-sel (.-selection kb-val)
            kb-start (.-start kb-sel)
            kb-end (.-end kb-sel)]
        
        ;; Detect text changes using improved diff logic
        (when (not= kb-text editor-text)
          (let [diff (text-diff/get-diff editor-text kb-text kb-start)
                inserted (:inserted diff)
                deleted (:deleted diff)]
            (when (pos? (count deleted))
              ;; For now, we use delete-backward! multiple times if needed, 
              ;; or better yet, delete-selection! if we can calculate the range.
              ;; Since kb-start is the new cursor position, we delete backward from where it was.
              (dotimes [_ (count deleted)]
                (cmd/delete-backward!)))
            (when (pos? (count inserted))
              (cmd/insert-text! inserted))))
        
        ;; Update selection position
        (when (not= [editor-start editor-end] [kb-start kb-end])
          ;; Selection position will be automatically updated in insert-text! or delete-backward!
          nil)))))

(defn sync-from-editor!
  "Sync editor state to virtual keyboard
   When editor state changes (e.g., selection changes, text changes, etc.), sync to virtual keyboard's editing state"
  []
  (let [editor-state @state/!editor-state
        selection (:selection editor-state)]
    (if selection
      ;; When there's a selection, sync to virtual keyboard
      (let [normalized (sel/normalize selection)
            path (:path (:start normalized))
            ks (node/path->ks path)
            delta-ks (if (some #{:delta} path) ks (conj ks :data :delta))
            delta (get-in editor-state (cons :doc delta-ks))
            text (delta-utils/delta->text delta)
            text-len (count text)
            start-offset (:offset (:start normalized))
            end-offset (:offset (:end normalized))
            ;; Clamp offsets to valid range to prevent "Range start X is out of text of length Y" errors
            clamped-start (max 0 (min start-offset text-len))
            clamped-end (max 0 (min end-offset text-len))
            
            ;; Only sync if relevant state (text or selection) changed
            relevant-state {:text text :sel [clamped-start clamped-end]}]
        (when (not= @last-synced-state relevant-state)
          (let [new-selection (w/TextSelection
                               .baseOffset clamped-start
                               .extentOffset clamped-end)
                new-editing-val (w/TextEditingValue
                                 .text text
                                 .selection new-selection)]
            ;; Update virtual keyboard's editing state
            (reset! control/editing-value new-editing-val)
            ;; Notify TextInput system to update editing state
            (service/TextInput.updateEditingValue new-editing-val)
            (reset! last-synced-state relevant-state))))
      ;; When selection is nil (e.g., clicked on blank area), reset virtual keyboard to empty state
      ;; This prevents RangeError when virtual keyboard tries to insert text at invalid positions
      (let [empty-state {:text "" :sel [0 0]}]
        (when (not= @last-synced-state empty-state)
          (let [empty-selection (w/TextSelection
                                 .baseOffset 0
                                 .extentOffset 0)
                empty-editing-val (w/TextEditingValue
                                   .text ""
                                   .selection empty-selection)]
            ;; Reset virtual keyboard's editing state to empty
            (reset! control/editing-value empty-editing-val)
            ;; Notify TextInput system to update editing state
            (service/TextInput.updateEditingValue empty-editing-val)
            (reset! last-synced-state empty-state)))))))

(defn initialize!
  "Initialize virtual keyboard service
   Set up input control and load necessary resource files"
  []
  (when-not @initialized?
    ;; Set up input control so virtual keyboard can interact with Flutter's TextInput system
    (control/set-control)
    
    ;; Load resource files required by virtual keyboard
    ;; These resource files contain candidate word data, etc.
    ;; Note: read-json-from-asset-zip is an async function, but we use synchronous approach during initialization
    ;; Actual loading will happen in the background
    (try
      (zip-utils/read-json-from-asset-zip kc/next "assets/next.zip")
      (fst-reader/ensure-loaded)
      (catch Exception e
        (dart:core/print (str "Warning: Could not load virtual keyboard resources: " e))))
    
    ;; Listen to virtual keyboard editing value changes, sync to editor
    (add-watch control/editing-value
               :virtual-keyboard-to-editor
               (fn [_ _ _ _]
                 (sync-to-editor!)))
    
    ;; Listen to editor state changes, sync to virtual keyboard
    (add-watch state/!editor-state
               :editor-to-virtual-keyboard
               (fn [_ _ _ _]
                 (sync-from-editor!)))
    
    (reset! initialized? true)
    (dart:core/print "Virtual keyboard service initialized")))

(defn initialize-editing-state!
  "Initialize virtual keyboard's editing state
   Call this function when editor gains focus to ensure virtual keyboard knows the current editing state"
  []
  (when @initialized?
    (sync-from-editor!)))

(defn shutdown!
  "Shutdown virtual keyboard service, restore platform default input control"
  []
  (when @initialized?
    (remove-watch control/editing-value :virtual-keyboard-to-editor)
    (remove-watch state/!editor-state :editor-to-virtual-keyboard)
    (control/restore-control)
    (reset! initialized? false)
    (dart:core/print "Virtual keyboard service shut down")))
