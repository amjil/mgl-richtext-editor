(ns rich-editor.services.desktop-input-service
  (:require
   ["package:flutter/services.dart" :as service]
   ["package:flutter/widgets.dart" :as w]
   ["package:flutter/foundation.dart" :as foundation]
   ["package:mgl_editor_core/desktop_text_input_client.dart" :refer [DesktopTextInputClient]]
   [clojure.string]
   [rich-editor.model.node :as node]
   [rich-editor.command.text-commands :as cmd]
   [rich-editor.state :as state]
   [rich-editor.model.selection :as sel]
   [rich-editor.utils.delta :as delta-utils]
   [rich-editor.model.delta :as delta]
   [rich-editor.utils.logger :as log]))

;; =============================================================
;; Desktop Text Input Service
;; Handles TextInputConnection for desktop platforms using Dart Client
;; =============================================================

(defonce ^:private text-input-connection (atom nil))
(defonce ^:private ^DesktopTextInputClient text-input-client-instance (atom nil))
(defonce ^:private last-attached-path (atom nil))

(defn- get-current-text []
  (let [editor-state @state/!editor-state
        selection (:selection editor-state)]
    (if selection
      (let [normalized (sel/normalize selection)
            start-path (:path (:start normalized))
            end-path (:path (:end normalized))
            start-offset (:offset (:start normalized))
            end-offset (:offset (:end normalized))]
        (if (= start-path end-path)
          ;; Single block selection
          (let [ks (node/path->ks start-path)
                delta-ks (if (some #{:delta} start-path) ks (conj ks :data :delta))
                delta (get-in (:doc editor-state) delta-ks)]
            (if delta (delta-utils/delta->text delta) ""))
          ;; Cross-block selection - concatenate text from multiple blocks
          (let [start-idx (first start-path)
                end-idx (first end-path)
                text-parts (loop [idx start-idx
                                  parts []]
                             (if (> idx end-idx)
                               parts
                               (let [block (get-in (:doc editor-state) [:children idx])
                                     current-delta (get-in block [:data :delta])
                                     copy-start (if (= idx start-idx) start-offset 0)
                                     copy-end (if (= idx end-idx) 
                                                end-offset 
                                                (count (delta-utils/delta->text current-delta)))
                                     text (delta-utils/delta->text 
                                           (delta/slice-delta current-delta copy-start copy-end))]
                                 (recur (inc idx) (conj parts text)))))
                full-text (clojure.string/join "\n" text-parts)]
            full-text)))
      "")))

(defn- get-current-selection []
  (let [editor-state @state/!editor-state
        selection (:selection editor-state)]
    ;; Reduce log noise, only output during debugging
    ;; (log/log-info (str "[Desktop Input] get-current-selection - selection: " selection))
    (if selection
      (let [normalized (sel/normalize selection)
            start-path (:path (:start normalized))
            end-path (:path (:end normalized))
            start-offset (:offset (:start normalized))
            end-offset (:offset (:end normalized))]
        (if (= start-path end-path)
          ;; Single block selection
          (let [ks (node/path->ks start-path)
                delta-ks (if (some #{:delta} start-path) ks (conj ks :data :delta))
                delta (get-in (:doc editor-state) delta-ks)
                text (if delta (delta-utils/delta->text delta) "")
                text-len (count text)
                clamped-start (max 0 (min start-offset text-len))
                clamped-end (max 0 (min end-offset text-len))
                result (w/TextSelection
                        :baseOffset clamped-start
                        :extentOffset clamped-end)
                ;; Only warn when offset is out of range and difference is significant (avoid noise from normal corrections on empty text)
                ;; It's normal for offset to be corrected from 1 to 0 when text is empty, no warning needed
                start-diff (max (- start-offset clamped-start) (- clamped-start start-offset))
                end-diff (max (- end-offset clamped-end) (- clamped-end end-offset))]
            (when (and (not= start-offset clamped-start) (> start-diff 1))
              (log/log-warn (str "[Desktop Input] get-current-selection corrected start-offset - original: " start-offset ", corrected: " clamped-start ", text-len: " text-len)))
            (when (and (not= end-offset clamped-end) (> end-diff 1))
              (log/log-warn (str "[Desktop Input] get-current-selection corrected end-offset - original: " end-offset ", corrected: " clamped-end ", text-len: " text-len)))
            result)
          ;; Cross-block selection - calculate offsets in concatenated text
          (let [start-idx (first start-path)
                end-idx (first end-path)
                ;; Calculate the length of text from start block (from start-offset to end)
                start-block (get-in (:doc editor-state) [:children start-idx])
                start-delta (get-in start-block [:data :delta])
                start-block-text (if start-delta (delta-utils/delta->text start-delta) "")
                start-block-len (count start-block-text)
                start-block-selected-len (- start-block-len start-offset)
                ;; Calculate cumulative length of intermediate blocks (with newlines)
                intermediate-len (if (= start-idx end-idx)
                                   0
                                   (loop [idx (inc start-idx)
                                          total 0]
                                     (if (>= idx end-idx)
                                       total
                                       (let [block (get-in (:doc editor-state) [:children idx])
                                             current-delta (get-in block [:data :delta])
                                             block-text (if current-delta (delta-utils/delta->text current-delta) "")
                                             block-len (count block-text)]
                                         (recur (inc idx) (+ total block-len 1)))))) ; +1 for newline
                ;; Start offset is just the offset in the first block
                final-start-offset start-offset
                ;; End offset = start block selected length + newline (if cross-block) + intermediate blocks length + end block offset
                newline-len (if (= start-idx end-idx) 0 1)
                final-end-offset (+ start-block-selected-len newline-len intermediate-len end-offset)
                text (get-current-text)
                text-len (count text)
                clamped-start (max 0 (min final-start-offset text-len))
                clamped-end (max 0 (min final-end-offset text-len))
                result (w/TextSelection
                        :baseOffset clamped-start
                        :extentOffset clamped-end)
                ;; Only warn when offset is out of range and difference is significant
                start-diff (max (- final-start-offset clamped-start) (- clamped-start final-start-offset))
                end-diff (max (- final-end-offset clamped-end) (- clamped-end final-end-offset))]
            (when (and (not= final-start-offset clamped-start) (> start-diff 1))
              (log/log-warn (str "[Desktop Input] get-current-selection corrected start-offset - original: " final-start-offset ", corrected: " clamped-start ", text-len: " text-len)))
            (when (and (not= final-end-offset clamped-end) (> end-diff 1))
              (log/log-warn (str "[Desktop Input] get-current-selection corrected end-offset - original: " final-end-offset ", corrected: " clamped-end ", text-len: " text-len)))
            result)))
      (w/TextSelection.collapsed :offset 0))))

(defn- init-client! []
  (when (nil? @text-input-client-instance)
    (reset! text-input-client-instance
            (DesktopTextInputClient
             .onInsertText (fn [text] (cmd/insert-text! text))
             .onDeleteSelection (fn [] (cmd/delete-selection!))
             .onDeleteBackward (fn [] (cmd/delete-backward!))
             .onDeleteForward (fn [] (cmd/delete-forward!))))))

(defn detach! []
  (when-let [conn @text-input-connection]
    (when (.-attached conn) (.close conn))
    (reset! text-input-connection nil)
    (reset! last-attached-path nil)))

(defn attach! []
  (when-not foundation/kIsWeb
    (let [editor-state @state/!editor-state
          selection (:selection editor-state)]
      (when selection
        (init-client!)
        (let [normalized (sel/normalize selection)
              current-path (:path (:start normalized))
              existing-conn @text-input-connection]
          ;; Only log when path changes or creating new connection
          (when (and existing-conn (not= @last-attached-path current-path))
            (log/log-info (str "[Desktop Input] attach! - path changed from " @last-attached-path " to " current-path ", detaching old connection"))
            (detach!))
          
          (let [conn @text-input-connection
                client ^DesktopTextInputClient @text-input-client-instance]
            (when (or (nil? conn) (not (.-attached conn)))
              (log/log-info (str "[Desktop Input] attach! - creating new connection for path: " current-path))
              (let [text (get-current-text)
                    text-selection (get-current-selection)
                    editing-value (w/TextEditingValue .text text .selection text-selection)
                    config (service/TextInputConfiguration
                            :inputAction service/TextInputAction.newline
                            :inputType service/TextInputType.multiline
                            :enableDeltaModel true)
                    new-conn (service.TextInput/attach client config)]
                (log/log-info (str "[Desktop Input] attach! - new connection created, attached?: " (.-attached new-conn)))
                (reset! text-input-connection new-conn)
                (reset! last-attached-path current-path)
                (set! (.-updatingFromEditor client) true)
                (try
                  (.updateState client editing-value)
                  (.setEditingState new-conn editing-value)
                  (.show new-conn)
                  (log/log-info (str "[Desktop Input] attach! - connection setup completed, attached?: " (.-attached new-conn)))
                  (finally
                    (set! (.-updatingFromEditor client) false)))))))))))

(defn update-editing-state! []
  (let [editor-state @state/!editor-state
        selection (:selection editor-state)]
    (when (and selection (some? @text-input-connection))
      (let [normalized (sel/normalize selection)
            current-path (:path (:start normalized))
            start-offset (:offset (:start normalized))
            client ^DesktopTextInputClient @text-input-client-instance]
        ;; Only log when path changes (which triggers attach!)
        (when (not= @last-attached-path current-path)
          (log/log-info (str "[Desktop Input] update-editing-state! - path changed, calling attach! - path: " current-path ", offset: " start-offset)))
        (if (not= @last-attached-path current-path)
          (attach!)
          (when-let [conn @text-input-connection]
            (when (and (.-attached conn) client)
              (let [text (get-current-text)
                    text-selection (get-current-selection)
                    editing-value (w/TextEditingValue :text text :selection text-selection)
                    current-value (.-currentTextEditingValue client)]
                ;; Only update when text or selection actually changes
                (when (or (nil? current-value)
                          (not= (.-text current-value) text)
                          (not= (.-baseOffset (.-selection current-value)) (.-baseOffset text-selection))
                          (not= (.-extentOffset (.-selection current-value)) (.-extentOffset text-selection)))
                  (set! (.-updatingFromEditor client) true)
                  (try
                    (.updateState client editing-value)
                    (.setEditingState conn editing-value)
                    (finally
                      (set! (.-updatingFromEditor client) false))))))))))))

(defn update-caret-position! [size transform rect]
  (when-let [conn @text-input-connection]
    (when (.-attached conn)
      (.setEditableSizeAndTransform conn size transform)
      (.setCaretRect conn rect))))
