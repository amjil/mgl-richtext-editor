(ns rich-editor.command.search-commands
  (:require [rich-editor.state :as state]
            [rich-editor.ui-state :as ui]
            [rich-editor.services.search-service :as search]
            [rich-editor.model.selection :as sel]))

;; =============================================================
;; Find and replace commands
;; =============================================================

(defn show-find-dialog!
  "Show find dialog"
  []
  (ui/update-search! assoc :show-dialog? true :replace-mode? false))

(defn show-replace-dialog!
  "Show replace dialog"
  []
  (ui/update-search! assoc :show-dialog? true :replace-mode? true))

(defn hide-find-dialog!
  "Hide find dialog"
  []
  (ui/update-search! assoc :show-dialog? false))

(defn update-search-term!
  "Update search term and execute search"
  [search-term]
  (let [case-sensitive? (get-in @ui/!ui-state [:search :case-sensitive?])
        doc (:doc @state/!editor-state)
        matches (search/search-in-document doc search-term case-sensitive?)
        current-index (if (seq matches) 0 -1)]
    (ui/update-search! assoc 
                       :search-term search-term 
                       :matches matches 
                       :current-match-index current-index)))

(defn toggle-case-sensitive!
  "Toggle case sensitive option"
  []
  (let [curr-search (:search @ui/!ui-state)
        new-case-sensitive? (not (:case-sensitive? curr-search))
        search-term (:search-term curr-search)
        doc (:doc @state/!editor-state)
        matches (search/search-in-document doc search-term new-case-sensitive?)
        current-index (if (seq matches) 0 -1)]
    (ui/update-search! assoc 
                       :case-sensitive? new-case-sensitive?
                       :matches matches 
                       :current-match-index current-index)))

(defn find-next!
  "Find next match"
  []
  (let [curr-search (:search @ui/!ui-state)
        matches (:matches curr-search)
        current-index (:current-match-index curr-search)
        new-index (search/find-next-match matches current-index)
        match (search/get-match-at-index matches new-index)]
    (when match
      (let [path (:path match)
            start (:start match)
            end (:end match)
            start-pos (sel/make-position path start)
            end-pos (sel/make-position path end)
            new-selection (sel/make-selection start-pos end-pos)]
        (ui/update-search! assoc :current-match-index new-index)
        (state/update-selection! new-selection)))))

(defn find-previous!
  "Find previous match"
  []
  (let [curr-search (:search @ui/!ui-state)
        matches (:matches curr-search)
        current-index (:current-match-index curr-search)
        new-index (search/find-previous-match matches current-index)
        match (search/get-match-at-index matches new-index)]
    (when match
      (let [path (:path match)
            start (:start match)
            end (:end match)
            start-pos (sel/make-position path start)
            end-pos (sel/make-position path end)
            new-selection (sel/make-selection start-pos end-pos)]
        (ui/update-search! assoc :current-match-index new-index)
        (state/update-selection! new-selection)))))

(defn replace-current!
  "Replace current match"
  [replacement]
  (let [curr-search (:search @ui/!ui-state)
        matches (:matches curr-search)
        current-index (:current-match-index curr-search)
        match (search/get-match-at-index matches current-index)]
    (when match
      (let [doc (:doc @state/!editor-state)
            updated-doc (search/replace-match doc match replacement)
            ;; Re-search because document has changed
            search-term (:search-term curr-search)
            case-sensitive? (:case-sensitive? curr-search)
            new-matches (search/search-in-document updated-doc search-term case-sensitive?)
            ;; Adjust index
            new-index (if (< current-index (count new-matches))
                       current-index
                       (max 0 (dec (count new-matches))))]
        (state/apply-action! (fn [_] updated-doc))
        (ui/update-search! assoc :matches new-matches :current-match-index new-index)))))

(defn replace-all!
  "Replace all matches"
  [replacement]
  (let [curr-search (:search @ui/!ui-state)
        matches (:matches curr-search)
        doc (:doc @state/!editor-state)
        updated-doc (search/replace-all-matches doc matches replacement)]
    (state/apply-action! (fn [_] updated-doc))
    (ui/update-search! assoc :matches [] :current-match-index -1)))

(defn update-replace-term!
  "Update replace term"
  [replace-term]
  (ui/update-search! assoc :replace-term replace-term))

