(ns rich-editor.state
  (:require [rich-editor.utils.history :as hist]
            [rich-editor.model.transaction :as tx]
            [rich-editor.model.node :as node]
            [rich-editor.utils.delta :as delta-utils]
            [rich-editor.utils.logger :as log]))

;; =============================================================
;; Constants
;; =============================================================

(def ^:private merge-interval-ms 1000)
(def ^:private selection-log-threshold 5)

;; 1. define the initial state
(defonce !editor-state
  (atom {:doc {:children [{:id "b1" :type :paragraph :data {:delta {:operations []}}}]}
         :selection nil
         :undo-stack []
         :redo-stack []
         :focused-path nil
         :last-edited-at 0
         :last-op-type nil})) ;; store the timestamp in milliseconds

;; Add watch to track all selection changes (only log path changes or significant offset changes)
(add-watch !editor-state :selection-tracker
  (fn [_ _ old-state new-state]
    (let [old-sel (:selection old-state)
          new-sel (:selection new-state)]
      (when (not= old-sel new-sel)
        (let [old-path (when old-sel (:path (:start old-sel)))
              new-path (when new-sel (:path (:start new-sel)))
              old-offset (when old-sel (:offset (:start old-sel)))
              new-offset (when new-sel (:offset (:start new-sel)))
              path-changed? (not= old-path new-path)
              offset-diff (when (and old-offset new-offset) (max (- new-offset old-offset) (- old-offset new-offset)))]
          ;; Only log when path changes or offset changes very significantly (normal multi-char input like IME is expected)
          ;; Threshold allows normal IME input (2-4 chars) without logging
          (when (or path-changed? (and offset-diff (> offset-diff selection-log-threshold)))
            (log/log-info (str "[Selection Tracker] selection modified - old: " old-sel ", new: " new-sel))))))))

(defn focus-block! [path]
  (swap! !editor-state assoc :focused-path path))

(defn update-selection! [new-selection]
  (let [old-selection (:selection @!editor-state)]
    ;; Only log significant selection changes (path changes or large offset differences)
    (when (not= old-selection new-selection)
      (let [old-path (when old-selection (:path (:start old-selection)))
            new-path (when new-selection (:path (:start new-selection)))
            old-offset (when old-selection (:offset (:start old-selection)))
            new-offset (when new-selection (:offset (:start new-selection)))
            path-changed? (not= old-path new-path)
            offset-diff (when (and old-offset new-offset) (max (- new-offset old-offset) (- old-offset new-offset)))]
        ;; Only log when path changes or offset changes very significantly (normal multi-char input like IME is expected)
        ;; Threshold allows normal IME input (2-4 chars) without logging
        (when (or path-changed? (and offset-diff (> offset-diff selection-log-threshold)))
          (log/log-info (str "[Selection State] update-selection! - old: " old-selection ", new: " new-selection)))))
    (swap! !editor-state assoc :selection new-selection)))

(defn apply-action! [action-fn & args]
  (swap! !editor-state (fn [curr]
                         (hist/push-history curr (apply action-fn (:doc curr) args)))))


;; 4. the internal tool function: determine whether to merge the history
(defn should-merge? [curr-state now-ms current-op-type]
  (let [last-time (:last-edited-at curr-state)
        last-op-type (:last-op-type curr-state)
        interval (- now-ms last-time)]
    ;; if the interval between two inputs is less than merge-interval-ms, the state is not empty,
    ;; and the operation type is the same as the last one, then merge
    (and (< interval merge-interval-ms) 
         (pos? last-time)
         (= last-op-type current-op-type))))

(defn commit-with-history! 
  "Commit a transaction with automatic history merging logic based on time and operation type."
  [transaction op-type]
  (let [curr @!editor-state
        now-ms (.-millisecondsSinceEpoch (dart:core/DateTime.now))
        merge? (should-merge? curr now-ms op-type)]
    (tx/commit-transaction! !editor-state transaction :merge? merge?)
    (swap! !editor-state assoc :last-edited-at now-ms :last-op-type op-type)))

;; 5. the core business logic function
(defn on-text-changed! [path new-delta]
  (let [curr @!editor-state
        children (get-in curr [:doc :children])
        idx (first path)
        current-selection (:selection curr)]
    (if (and (number? idx) (>= idx 0) (< idx (count children)))
      (let [;; Determine operation type (insert vs delete) by comparing text length
            old-delta (get-in curr (cons :doc (node/path->ks path)))
            old-len (count (delta-utils/delta->text old-delta))
            new-len (count (delta-utils/delta->text new-delta))
            current-op-type (cond 
                              (> new-len old-len) :insert
                              (< new-len old-len) :delete
                              :else :other)
            ;; Wrap the text update in a transaction
            transaction (tx/make-transaction
                         :ops [(tx/update-text-op path new-delta)]
                         :after-selection current-selection)]
        (commit-with-history! transaction current-op-type))
      (log/log-warn (str "Ignored on-text-changed! with invalid path: " path)))))

(defn update-block-data! [path data]
  (let [curr @!editor-state
        children (get-in curr [:doc :children])
        idx (first path)]
    (if (and (number? idx) (>= idx 0) (< idx (count children)))
      (let [            transaction (tx/make-transaction
                         :ops [(tx/update-data-op path data)]
                         :after-selection (:selection curr))]
        (tx/commit-transaction! !editor-state transaction))
      (log/log-warn (str "Ignored update-block-data! with invalid path: " path)))))

(defn delete-block! [path]
  (let [curr @!editor-state
        idx (first path)
        old-children (get-in curr [:doc :children])]
    (if (and (number? idx) (>= idx 0) (< idx (count old-children)))
      (if (<= (count old-children) 1)
        ;; If it's the last block, don't delete it, just clear its content
        (on-text-changed! path {:operations []})
        (let [new-focused-path [(max 0 (dec idx))]
              ;; Update selection to the previous block if current one is deleted
              new-selection (when (:selection curr)
                              (let [sel (:selection curr)
                                    new-idx (max 0 (dec idx))]
                                (-> sel
                                    (assoc-in [:start :path 0] new-idx)
                                    (assoc-in [:end :path 0] new-idx)
                                    (assoc-in [:start :offset] 0)
                                    (assoc-in [:end :offset] 0))))
              transaction (tx/make-transaction
                           :ops [(tx/delete-op path 1)]
                           :after-selection new-selection)]
          (tx/commit-transaction! !editor-state transaction)
          (swap! !editor-state assoc :focused-path new-focused-path :selection new-selection)))
      (log/log-warn (str "Ignored delete-block! with invalid path: " path)))))
