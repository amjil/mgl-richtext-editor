(ns rich-editor.state
  (:require [rich-editor.utils.history :as hist]
            [rich-editor.model.transaction :as tx]
            [rich-editor.model.node :as node]
            [rich-editor.utils.delta :as delta-utils]
            [rich-editor.utils.logger :as log]
            [rich-editor.utils.events :as events]
            [rich-editor.utils.validation :as validation]
            [rich-editor.utils.result :as result]))

;; =============================================================
;; Constants
;; =============================================================

(def ^:private merge-interval-ms 1000)

;; =============================================================
;; Default Initial State
;; =============================================================

(def default-doc
  "Default empty document"
  {:children [{:id "b1" :type :paragraph :data {:delta {:operations []}}}]})

(defn create-editor-state
  "Create a new editor state atom (functional, allows dependency injection)"
  [initial-doc]
  (atom {:doc (or initial-doc default-doc)
         :selection nil
         :undo-stack []
         :redo-stack []
         :focused-path nil
         :last-edited-at 0
         :last-op-type nil}))

;; 1. define the initial state (global, for backward compatibility)
(defonce !editor-state
  (create-editor-state default-doc))

;; Setup event dispatcher for global state
(events/setup-event-dispatcher !editor-state)

;; Callback for onChange events
(defonce !on-change-callback (atom nil))

(defn set-on-change-callback!
  "Set the onChange callback function. Callback receives a map with :doc and :selection keys."
  [callback]
  (reset! !on-change-callback callback))

(defn clear-on-change-callback!
  "Clear the onChange callback."
  []
  (reset! !on-change-callback nil))

;; =============================================================
;; Functional State Update Functions (Pure)
;; =============================================================

(defn update-selection
  "Pure function: update selection in state"
  [state new-selection]
  (assoc state :selection new-selection))

(defn update-doc
  "Pure function: update doc in state"
  [state new-doc]
  (assoc state :doc new-doc))

(defn update-focused-path
  "Pure function: update focused path in state"
  [state focused-path]
  (assoc state :focused-path focused-path))

(defn compose-state-updates
  "Compose multiple state update functions"
  [& update-fns]
  (fn [state]
    (reduce (fn [acc update-fn] (update-fn acc)) state update-fns)))

;; =============================================================
;; Legacy Watch Handlers (kept for backward compatibility, will be replaced by events)
;; =============================================================

;; Subscribe to events for onChange callback
(defonce !on-change-unsubscribe
  (events/subscribe :doc-changed
                    (fn [event]
                      (when-let [callback @!on-change-callback]
                        (try
                          (callback {:doc (:doc (:data event))
                                    :selection (:selection @!editor-state)})
                          (catch Exception e
                            (log/log-warn (str "Error in onChange callback: " e))))))))

;; =============================================================
;; State Mutation Functions (with validation and events)
;; =============================================================

(defn focus-block!
  "Update focused block path (functional, accepts optional state)"
  ([path] (focus-block! !editor-state path))
  ([state path]
   (if (validation/valid-path? path)
     (do
       (swap! state assoc :focused-path path)
       (events/emit :focus-changed {:focused-path path}))
     (log/log-warn (str "Invalid path in focus-block!: " path)))))

(defn update-selection!
  "Update selection (functional, accepts optional state, validates input)"
  ([new-selection] (update-selection! !editor-state new-selection))
  ([state new-selection]
   (let [validation-result (validation/validate-selection new-selection)]
     (if (result/is-ok? validation-result)
       (let [valid-selection (:value validation-result)
             old-selection (:selection @state)]
         ;; Log significant changes (for debugging)
         (when (not= old-selection valid-selection)
           (let [old-path (when old-selection (:path (:start old-selection)))
                 new-path (when valid-selection (:path (:start valid-selection)))
                 path-changed? (not= old-path new-path)]
             (when path-changed?
               (log/log-info (str "[Selection] path changed: " old-path " -> " new-path)))))
         (swap! state update-selection valid-selection))
       (do
         (log/log-warn (str "Invalid selection in update-selection!: " (:error validation-result)))
         validation-result)))))

(defn apply-action! [action-fn & args]
  (swap! !editor-state (fn [curr]
                         (hist/push-history curr (apply action-fn (:doc curr) args)))))


;; 4. the internal tool function: determine whether to merge the history
(defn should-merge? [curr-state now-ms current-op-type]
  (let [last-time (:last-edited-at curr-state)
        last-op-type (:last-op-type curr-state)
        interval (- now-ms last-time)]
    ;; if the interval between two inputs is less than merge-interval-ms, the state is not empty,
    ;; and the operation type is the same as the last one, then merge
    (and (< interval merge-interval-ms) 
         (pos? last-time)
         (= last-op-type current-op-type))))

(defn commit-with-history! 
  "Commit a transaction with automatic history merging logic based on time and operation type."
  [transaction op-type]
  (let [curr @!editor-state
        now-ms (.-millisecondsSinceEpoch (dart:core/DateTime.now))
        merge? (should-merge? curr now-ms op-type)]
    (tx/commit-transaction! !editor-state transaction :merge? merge?)
    (swap! !editor-state assoc :last-edited-at now-ms :last-op-type op-type)))

;; 5. the core business logic function
(defn on-text-changed! [path new-delta]
  (let [curr @!editor-state
        children (get-in curr [:doc :children])
        idx (first path)
        current-selection (:selection curr)]
    (if (and (number? idx) (>= idx 0) (< idx (count children)))
      (let [;; Determine operation type (insert vs delete) by comparing text length
            old-delta (get-in curr (cons :doc (node/path->ks path)))
            old-len (count (delta-utils/delta->text old-delta))
            new-len (count (delta-utils/delta->text new-delta))
            current-op-type (cond 
                              (> new-len old-len) :insert
                              (< new-len old-len) :delete
                              :else :other)
            ;; Wrap the text update in a transaction
            transaction (tx/make-transaction
                         :ops [(tx/update-text-op path new-delta)]
                         :after-selection current-selection)]
        (commit-with-history! transaction current-op-type))
      (log/log-warn (str "Ignored on-text-changed! with invalid path: " path)))))

(defn update-block-data! [path data]
  (let [curr @!editor-state
        children (get-in curr [:doc :children])
        idx (first path)]
    (if (and (number? idx) (>= idx 0) (< idx (count children)))
      (let [            transaction (tx/make-transaction
                         :ops [(tx/update-data-op path data)]
                         :after-selection (:selection curr))]
        (tx/commit-transaction! !editor-state transaction))
      (log/log-warn (str "Ignored update-block-data! with invalid path: " path)))))

(defn delete-block! [path]
  (let [curr @!editor-state
        idx (first path)
        old-children (get-in curr [:doc :children])]
    (if (and (number? idx) (>= idx 0) (< idx (count old-children)))
      (if (<= (count old-children) 1)
        ;; If it's the last block, don't delete it, just clear its content
        (on-text-changed! path {:operations []})
        (let [new-focused-path [(max 0 (dec idx))]
              ;; Update selection to the previous block if current one is deleted
              new-selection (when (:selection curr)
                              (let [sel (:selection curr)
                                    new-idx (max 0 (dec idx))]
                                (-> sel
                                    (assoc-in [:start :path 0] new-idx)
                                    (assoc-in [:end :path 0] new-idx)
                                    (assoc-in [:start :offset] 0)
                                    (assoc-in [:end :offset] 0))))
              transaction (tx/make-transaction
                           :ops [(tx/delete-op path 1)]
                           :after-selection new-selection)]
          (tx/commit-transaction! !editor-state transaction)
          (swap! !editor-state assoc :focused-path new-focused-path :selection new-selection)))
      (log/log-warn (str "Ignored delete-block! with invalid path: " path)))))
